stages:
  - before-go
  - set-image-ver-master-go
  - set-image-ver-master
  - set-image-ver-worker
  - set-helm-ver
  - build-master-image
  - build-worker-image
  - build-app-helm
  - deploy-$IMAGE

variables:
  HELM_REPO: "postinstall"
  APP_REPO: app-repo-name
  IMAGE_MASTER: master-npd
  IMAGE_WORKER: worker-npd
  IMAGE_MANAGER_CRBC: application-name
  HELM_CHART_DIR_NAME: helm-chart-name

before-go:
  stage: before-go
  artifacts:
    reports:
      dotenv: build.env
  rules:
    - if: '$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "dev"'
  script:
    - |
      set +e 
      podman login -u $HARBOR_USER -p $HARBOR_PASS $HOST_REGISTRY
      # used "true" because tags may empty
      # file build.env can't contain (\n)
      TAGS=$(podman search --list-tags "$HOST_REGISTRY/$APP_REPO/$IMAGE_MANAGER_CRBC" --format "{{.Name}}:{{.Tag}}" | tr '\n' ',' | sed 's/,$//' || true)
      echo "tags result: $TAGS"
      echo "TAGS=$TAGS" > build.env # var should be with double comma

set-image-ver-master-go:
  stage: set-image-ver-master-go
  dependencies: # Нужно явно указывать зависимость от previous stage
    - before-go
  artifacts:                       #artifacts  allow to save data after job is finished
    reports:
      dotenv: build.env            file with vars, this var will be shared with another jobs
  image: $HOST_REGISTRY/golang/golang:1.24.0
  rules:
    - if: '$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "dev"'
  script:
    - |
      go version
      ls -la
      echo $TAGS
      TAGS=1.0.0
      go mod init notused || true
      go run ./scripts/set-image-ver-master-go.go # run golang 


# Varibles
CI_PROJECT_NAME - project name for your applications
'$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "dev"' - branch name 
Runner - it is separate process which one work on gitlab or another machine


1. artifacts:reports:dotenv
Назначение: специальный тип артефактов для автоматической загрузки переменных окружения в последующие джобы пайплайна.

artifacts:
  reports:
    dotenv: путь/к/файлу.env

Как работает:
Файл в формате .env (каждая строка — КЛЮЧ=значение) сохраняется как артефакт.
GitLab автоматически импортирует все переменные из этого файла в среду последующих джоб (в том же пайплайне).
Переменные становятся доступны как обычные переменные окружения (например, $MY_VAR)

Когда использовать:
Когда нужно передать переменные между джобами без ручного подключения.
Для динамических значений, генерируемых в процессе пайплайна (версии, теги, URL и т.п.).
Пример: передача тегов Docker-образов из джобы сканирования в джобу сборки.

generate-vars:
  script:
    - echo "APP_VERSION=1.2.3" > build.env
    - echo "BUILD_TIME=$(date +%s)" >> build.env
  artifacts:
    reports:
      dotenv: build.env

use-vars:
  script:
    - echo "Версия приложения: $APP_VERSION"  # Автоматически доступно!
    - echo "Время сборки: $BUILD_TIME"

2. artifacts:paths
Назначение: общее сохранение файлов/директорий как артефактов для ручного использования в последующих джобах.

Синтаксис:

yaml
artifacts:
  paths:
    - путь/к/файлу
    - путь/к/директории/
Как работает:
Файлы копируются в хранилище артефактов.
В последующих джобах их нужно вручную копировать из директории $CI_PROJECT_DIR (или другой указанной).
Переменные из .env-файлов не импортируются автоматически — их надо подключать явно (например, через source).

Когда использовать:
Для передачи бинарных файлов, логов, конфигураций.
Когда нужен контроль над моментом загрузки переменных.
Для артефактов, не являющихся переменными окружения.

Пример:
save-file:
  script:
    - echo "data=hello" > config.env
  artifacts:
    paths:
      - config.env

use-file:
  script:
    - cp $CI_PROJECT_DIR/config.env ./  # Вручную копируем
    - source config.env                   # Вручную загружаем переменные
    - echo $data  # Теперь доступно


###  An example how to push var to next job ###
1. Первая задача (get-tag-podman) собирает список тегов и записывает его в файл build.env.
2. Файл build.env передается как артефакт следующему этапу (validate-image-ver-master).
3. Вторая задача загружает переменные окружения из файла build.env перед выполнением скрипта.

get-tag-podman:
  stage: get-tag-podman
  artifacts:
    reports:
      dotenv: build.env
  rules:
    - if: '$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "dev"'
  script:
    - |
      # set +e 
      podman login -u $HARBOR_USER -p $HARBOR_PASS $HOST_REGISTRY
      # used "true" because tags may empty
      # file build.env can't contain (\n)
      TAGS=$(podman search --list-tags "$HOST_REGISTRY/$APP_REPO/$IMAGE_MANAGER_CRBC" --format "{{.Name}}:{{.Tag}}" | tr '\n' ',' | sed 's/,$//' || true)
      echo "Tags result: $TAGS"
      echo "TAGS=$TAGS" > build.env # var should be with double comma

validate-image-ver-master:
  stage: validate-image-ver-master
  dependencies: # Need specify dependence from  previous stage
    - get-tag-podman
  artifacts:                       # artifacts  allow to save data after job is finished
    reports:
      dotenv: build.env            # file with vars, this var will be shared with another jobs with dotenv.env you can push your var to container
  image: $HOST_REGISTRY/golang/golang:1.24.0
  rules:
    - if: '$CI_COMMIT_BRANCH == "master" || $CI_COMMIT_BRANCH == "dev"'
  script:
    - |
      # go run ./scripts/set-image-ver-master-go.go "$TAGS" > build.env <<< another way to get value from previous job with args[0]
      # source build.env # used if you use path
      # echo "Tags before check: $TAGS"
      go run ./scripts/set-image-ver-master-go.go #> build.env
      echo "Tags after check $TAGS"
      echo "TAGS=$TAGS" 
################################################################################################
